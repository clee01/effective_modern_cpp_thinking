# Table of contents

* [前言](README.md)
* [1 类型推导](1_deducing_types/README.md)
  * [1.1 理解模板类型推导](1_deducing_types/1_understand_template_type_deduction.md)
  * [1.2 理解auto类型推导](1_deducing_types/2_understand_auto_type_deduction.md)
  * [1.3 理解decltype](1_deducing_types/3_understand_decltype.md)
  * [1.4 知道如何查看类型推导](1_deducing_types/4_view_deduced_types.md)
* [2 auto](2_auto/README.md)
  * [2.1 优先使用auto而非显式声明](2_auto/5_prefer_auto.md)
  * [2.2 当auto推导出非预期类型时应当使用显式的类型初始化](2_auto/6_use_explicitly_typed_initializer.md)
* [3 使用高级cpp特性](3_moving_to_modern_cpp/README.md)
  * [3.1 创造对象时区分()和{}](3_moving_to_modern_cpp/7_distinguish_between_parens_and_braces.md)
  * [3.2 优先使用nullptr而不是0或者NULL](3_moving_to_modern_cpp/8_prefer_nullptr.md)
  * [3.3 优先使用声明别名而不是typedef](3_moving_to_modern_cpp/9_prefer_alias_declarations.md)
  * [3.4 优先使用作用域限制的enum而不是无作用域的enum](3_moving_to_modern_cpp/10_prefer_scoped_enums.md)
  * [3.5 优先使用delete关键字删除函数而不是private却又不实现的函数](3_moving_to_modern_cpp/11_prefer_deleted_functions_to_private_undefined_ones.md)
  * [3.6 使用override关键字声明覆盖的函数](3_moving_to_modern_cpp/12_declare_overriding_functions_override.md)
  * [3.7 优先使用const_iterator而不是iterator](3_moving_to_modern_cpp/13_prefer_const_iterators_to_iterators.md)
  * [3.8 如果函数不抛出异常请使用noexcept](3_moving_to_modern_cpp/14_declare_functions_noexcept.md)
  * [3.9 尽可能使用constexpr](3_moving_to_modern_cpp/15_use_constexpr_whenever_possible.md)
  * [3.10 让const成员函数线程安全](3_moving_to_modern_cpp/16_make_const_member_functions_thread_safe.md)
  * [3.11 理解特殊成员函数的生成](3_moving_to_modern_cpp/17_understand_special_member_function_generation.md)
* [4 智能指针](4_smart_pointers/README.md)
  * [4.1 对于独占资源使用std::unique_ptr](4_smart_pointers/18_use_std_unique_ptr_for_exclusive.md)
  * [4.2 对于共享资源使用std::shared_ptr](4_smart_pointers/19_use_std_shared_ptr_for_shared.md)
  * [4.3 当std::shared_ptr可能悬空时使用std::weak_ptr](4_smart_pointers/20_use_std_weak_ptr_for_shared_ptr-like_pointers_that_can_dangle.md)
  * [4.4 优先考虑使用std::make_unique和std::make_shared，而非直接使用new](4_smart_pointers/21_prefer_std_make_unique_and_make_shared.md)
  * [4.5 当使用Pimpl惯用法，请在实现文件中定义特殊成员函数](4_smart_pointers/22_using_the_pimpl_idiom.md)
* [5 右值引用和完美转发](5_rvalue_references_move_semantics_and_perfect_forwarding/README.md)
  * [5.1 理解std::move和std::forward](5_rvalue_references_move_semantics_and_perfect_forwarding/23_understand_std_move_and_forward.md)
  * [5.2 区分通用引用和右值引用](5_rvalue_references_move_semantics_and_perfect_forwarding/24_distinguish_universal_references.md)
  * [5.3 对右值引用使用std::move，对通用引用使用std::forward](5_rvalue_references_move_semantics_and_perfect_forwarding/25_use_std_move_on_rvalue_references_etc.md)
  * [5.4 避免在通用引用上重载](5_rvalue_references_move_semantics_and_perfect_forwarding/26_avoid_overloading_on_universal_references.md)
  * [5.5 熟悉通用引用重载的替代方法](5_rvalue_references_move_semantics_and_perfect_forwarding/27_familiarize_with_alternatives_to_overloading_on_universal_references.md)
  * [5.6 理解引用折叠](5_rvalue_references_move_semantics_and_perfect_forwarding/28_understand_reference_collapsing.md)
  * [5.7 假定移动操作不存在，成本高，未被使用](5_rvalue_references_move_semantics_and_perfect_forwarding/29_assume_move_operations_not.md)
  * [5.8 熟悉完美转发失败的情况](5_rvalue_references_move_semantics_and_perfect_forwarding/30_familiarize_yourself_with_perfect_forwardind_failure.md)
* [6 lambda表达式](6_lambda_expressions/README.md)
  * [6.1 避免使用默认捕获模式](6_lambda_expressions/31_avoid_default_capture_modes.md)
  * [6.2 使用初始化捕获来移动对象到闭包中](6_lambda_expressions/32_use_init_capture_to_move_objects_into_closures.md)
  * [6.3 对auto&&形参使用decltype以便std::forward它们](6_lambda_expressions/33_use_decltype_on_auto_universal_ref.md)
  * [6.4 考虑lambda而非std::bind](6_lambda_expressions/34_prefer_lambdas_to_std_bind.md)
* [7 并发api](7_the_concurrency_api/README.md)
  * [7.1 优先考虑基于任务的编程而非基于线程的编程](7_the_concurrency_api/35_prefer_task-based_programming_to_thread-based.md)
  * [7.2 如果有异步的必要请指定std::async::launch](7_the_concurrency_api/36_specify_std_async_launch_if_asynchronicity_if_essential.md)
  * [7.3 使std::thread在所有路径最后都不可结合](7_the_concurrency_api/37_make_std_threads_unjoinable_on_all_paths.md)
  * [7.4 关注不同线程句柄的析构行为](7_the_concurrency_api/38_be_aware_of_varying_thread_handle_destructor_behavior.md)
  * [7.5 对于一次性事件通信考虑使用void的futures](7_the_concurrency_api/39_consider_void_futures_for_one-shot.md)
  * [7.6 对于并发使用std::atomic，对于特殊内存使用volatile](7_the_concurrency_api/40_use_std_atomic_for_concurrency.md)
* [8 些许调整](8_tweaks.md/README.md)
  * [8.1 对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递](8_tweaks.md/41_consider_pass_by_value_for_copyable_param.md)
  * [8.2 考虑使用置入代替插入](8_tweaks.md/42_consider_emplacement_instead_of_insertion.md)
