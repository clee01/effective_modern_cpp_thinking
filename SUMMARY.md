# Table of contents

* [前言](README.md)
* [1 类型推导](1_deducing_types/README.md)
  * [条款1 理解模板类型推导](1_deducing_types/1_understand_template_type_deduction.md)
  * [条款2 理解auto类型推导](1_deducing_types/2_understand_auto_type_deduction.md)
  * [条款3 理解decltype](1_deducing_types/3_understand_decltype.md)
  * [条款4 知道如何查看类型推导](1_deducing_types/4_view_deduced_types.md)
* [2 auto](2_auto/README.md)
  * [条款5 优先使用auto而非显式声明](2_auto/5_prefer_auto.md)
  * [条款6 当auto推导出非预期类型时应当使用显式的类型初始化](2_auto/6_use_explicitly_typed_initializer.md)
* [3 使用高级cpp特性](3_moving_to_modern_cpp/README.md)
  * [条款7 创造对象时区分()和{}](3_moving_to_modern_cpp/7_distinguish_between_parens_and_braces.md)
  * [条款8 优先使用nullptr而不是0或者NULL](3_moving_to_modern_cpp/8_prefer_nullptr.md)
  * [条款9 优先使用声明别名而不是typedef](3_moving_to_modern_cpp/9_prefer_alias_declarations.md)
  * [条款10 优先使用作用域限制的enum而不是无作用域的enum](3_moving_to_modern_cpp/10_prefer_scoped_enums.md)
  * [条款11 优先使用delete关键字删除函数而不是private却又不实现的函数](3_moving_to_modern_cpp/11_prefer_deleted_functions_to_private_undefined_ones.md)
  * [条款12 使用override关键字声明覆盖的函数](3_moving_to_modern_cpp/12_declare_overriding_functions_override.md)
  * [条款13 优先使用const_iterator而不是iterator](3_moving_to_modern_cpp/13_prefer_const_iterators_to_iterators.md)
  * [条款14 如果函数不抛出异常请使用noexcept](3_moving_to_modern_cpp/14_declare_functions_noexcept.md)
  * [条款15 尽可能使用constexpr](3_moving_to_modern_cpp/15_use_constexpr_whenever_possible.md)
  * [条款16 让const成员函数线程安全](3_moving_to_modern_cpp/16_make_const_member_functions_thread_safe.md)
  * [条款17 理解特殊成员函数的生成](3_moving_to_modern_cpp/17_understand_special_member_function_generation.md)
* [4 智能指针](4_smart_pointers/README.md)
  * [条款18 对于独占资源使用std::unique_ptr](4_smart_pointers/18_use_std_unique_ptr_for_exclusive.md)
  * [条款19 对于共享资源使用std::shared_ptr](4_smart_pointers/19_use_std_shared_ptr_for_shared.md)
  * [条款20 当std::shared_ptr可能悬空时使用std::weak_ptr](4_smart_pointers/20_use_std_weak_ptr_for_shared_ptr-like_pointers_that_can_dangle.md)
  * [条款21 优先考虑使用std::make_unique和std::make_shared，而非直接使用new](4_smart_pointers/21_prefer_std_make_unique_and_make_shared.md)
  * [条款22 当使用Pimpl惯用法，请在实现文件中定义特殊成员函数](4_smart_pointers/22_using_the_pimpl_idiom.md)
* [5 右值引用和完美转发](5_rvalue_references_move_semantics_and_perfect_forwarding/README.md)
  * [条款23 理解std::move和std::forward](5_rvalue_references_move_semantics_and_perfect_forwarding/23_understand_std_move_and_forward.md)
  * [条款24 区分通用引用和右值引用](5_rvalue_references_move_semantics_and_perfect_forwarding/24_distinguish_universal_references.md)
  * [条款25 对右值引用使用std::move，对通用引用使用std::forward](5_rvalue_references_move_semantics_and_perfect_forwarding/25_use_std_move_on_rvalue_references_etc.md)
  * [条款26 避免在通用引用上重载](5_rvalue_references_move_semantics_and_perfect_forwarding/26_avoid_overloading_on_universal_references.md)
  * [条款27 熟悉通用引用重载的替代方法](5_rvalue_references_move_semantics_and_perfect_forwarding/27_familiarize_with_alternatives_to_overloading_on_universal_references.md)
  * [条款28 理解引用折叠](5_rvalue_references_move_semantics_and_perfect_forwarding/28_understand_reference_collapsing.md)
  * [条款29 假定移动操作不存在，成本高，未被使用](5_rvalue_references_move_semantics_and_perfect_forwarding/29_assume_move_operations_not.md)
  * [条款30 熟悉完美转发失败的情况](5_rvalue_references_move_semantics_and_perfect_forwarding/30_familiarize_yourself_with_perfect_forwardind_failure.md)
* [6 lambda表达式](6_lambda_expressions/README.md)
  * [条款31 避免使用默认捕获模式](6_lambda_expressions/31_avoid_default_capture_modes.md)
  * [条款32 使用初始化捕获来移动对象到闭包中](6_lambda_expressions/32_use_init_capture_to_move_objects_into_closures.md)
  * [条款33 对auto&&形参使用decltype以便std::forward它们](6_lambda_expressions/33_use_decltype_on_auto_universal_ref.md)
  * [条款34 考虑lambda而非std::bind](6_lambda_expressions/34_prefer_lambdas_to_std_bind.md)
* [7 并发api](7_the_concurrency_api/README.md)
  * [条款35 优先考虑基于任务的编程而非基于线程的编程](7_the_concurrency_api/35_prefer_task-based_programming_to_thread-based.md)
  * [条款36 如果有异步的必要请指定std::async::launch](7_the_concurrency_api/36_specify_std_async_launch_if_asynchronicity_if_essential.md)
  * [条款37 使std::thread在所有路径最后都不可结合](7_the_concurrency_api/37_make_std_threads_unjoinable_on_all_paths.md)
  * [条款38 关注不同线程句柄的析构行为](7_the_concurrency_api/38_be_aware_of_varying_thread_handle_destructor_behavior.md)
  * [条款39 对于一次性事件通信考虑使用void的futures](7_the_concurrency_api/39_consider_void_futures_for_one-shot.md)
  * [条款40 对于并发使用std::atomic，对于特殊内存使用volatile](7_the_concurrency_api/40_use_std_atomic_for_concurrency.md)
* [8 些许调整](8_tweaks.md/README.md)
  * [条款41 对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递](8_tweaks.md/41_consider_pass_by_value_for_copyable_param.md)
  * [条款42 考虑使用置入代替插入](8_tweaks.md/42_consider_emplacement_instead_of_insertion.md)
